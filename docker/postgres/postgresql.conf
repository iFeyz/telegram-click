# PostgreSQL Configuration for High-Concurrency Clicker Game
# Optimized for 8GB RAM server with SSD storage

# ===================================================================
# CONNECTION SETTINGS
# ===================================================================
# Listen on all interfaces (required for Docker networking)
listen_addresses = '*'

max_connections = 1000
superuser_reserved_connections = 3

# ===================================================================
# MEMORY SETTINGS (for 8GB RAM server)
# ===================================================================
# shared_buffers: Memory for caching data (25% of RAM)
shared_buffers = 2GB

# effective_cache_size: OS cache size hint for query planner (75% of RAM)
effective_cache_size = 6GB

# maintenance_work_mem: Memory for maintenance operations (VACUUM, CREATE INDEX)
maintenance_work_mem = 512MB

# work_mem: Memory per query operation (sort, hash)
# Total can be: max_connections * work_mem, so keep conservative
work_mem = 32MB

# ===================================================================
# WRITE-AHEAD LOG (WAL) SETTINGS
# ===================================================================
# wal_buffers: Buffer for WAL data before writing to disk
wal_buffers = 16MB

# checkpoint settings: Balance between crash recovery and performance
checkpoint_completion_target = 0.9
checkpoint_timeout = 10min
max_wal_size = 4GB
min_wal_size = 1GB

# WAL write mode (default is good for most cases)
synchronous_commit = on
wal_compression = on

# ===================================================================
# QUERY PLANNER
# ===================================================================
# random_page_cost: Lower for SSD (1.1) vs HDD (4.0)
random_page_cost = 1.1
effective_io_concurrency = 200

# ===================================================================
# PARALLEL QUERY SETTINGS
# ===================================================================
max_parallel_workers_per_gather = 4
max_parallel_workers = 8
max_worker_processes = 8

# ===================================================================
# LOGGING
# ===================================================================
# Log slow queries (> 1 second)
log_min_duration_statement = 1000

# Connection logging
log_connections = on
log_disconnections = on

# Log format
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_timezone = 'UTC'

# ===================================================================
# MONITORING & STATISTICS
# ===================================================================
# pg_stat_statements extension for query performance monitoring
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.track = all
pg_stat_statements.max = 10000

# Track IO timing (useful for performance analysis)
track_io_timing = on

# Update statistics for better query planning
default_statistics_target = 100

# ===================================================================
# AUTOVACUUM TUNING
# ===================================================================
# Aggressive autovacuum for high-write workload
autovacuum = on
autovacuum_max_workers = 4
autovacuum_naptime = 10s

# Vacuum more aggressively when table bloat reaches 5%
autovacuum_vacuum_scale_factor = 0.05
autovacuum_analyze_scale_factor = 0.02

# ===================================================================
# LOCALE & FORMATTING
# ===================================================================
datestyle = 'iso, mdy'
timezone = 'UTC'
lc_messages = 'en_US.utf8'
lc_monetary = 'en_US.utf8'
lc_numeric = 'en_US.utf8'
lc_time = 'en_US.utf8'
default_text_search_config = 'pg_catalog.english'

# ===================================================================
# REPLICATION (for future read replicas - optional)
# ===================================================================
# Uncomment these when adding read replicas:
# wal_level = replica
# max_wal_senders = 10
# wal_keep_size = 1GB
# hot_standby = on
# hot_standby_feedback = on
